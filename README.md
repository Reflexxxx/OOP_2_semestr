# OOP_2_semestr
OOP second semester
Лабы четвертого семестра

#Task 1

Частина 1. Conceptual/Domain Modeling Змоделювати з використанням UML роботу користувача з популярними сервісами (конкретний сервіс залежно від варіанту). Створити глосарій та описати предметну область, основні рішення з архітектури та проектування у вигляді UML діаграм. Код писати не потрібно (хоча можна, за бажання). Бажано описати загалом основну функціональність (діаграми Use Case, Class, Component, Deployment, Package) і вибрати кілька (3-5) сценаріїв використання для більш детального опису (діаграми Object, Composite Structure, Sequence, Communication, Timing, Activity, Interaction Overview, State, Profile). Бажано використовувати різноманітні діаграми UML 2.x – щоб зрозуміти, в чому між ними відмінність та де їх використовують. Якщо якийсь з 14 типів діаграм не використовувався – треба пояснити, чому. Для деяких типів діаграм варто реалізувати кілька діаграм одного типу, наприклад для ілюстрації різних сценаріїв використання чи різних компонентів. Для отримання додаткових балів можна подумати, якої функціональності не вистачає в обраному сервісі, чи що можна було б покращити, і спроектувати реалізацію цієї функціональності (з використанням UML діаграм). Кожен варіант описує конкретний сервіс. Можна обрати аналогічний сервіс замість того, який вказано у списку (наприклад, замість Google Maps можна змоделювати Bing Maps чи OpenStreetMap). Проте не варто моделювати якісь абстрактні сервіси (систему мап взагалі) – краще обрати конкретний сервіс і описувати його. Варіанти: 2. Web mail (e.g. GMail)

Частина 2. Design/Implementation Modeling Використати UML діаграми для опису структури існуючого коду та його рефакторінгу. Виконання цієї частини складається з наступних кроків:

Обрати існуючу програму/проект, з якою планується працювати. Це може бути навчальний проект з минулого семестру, чи одна з лабораторних робіт, чи код з інших предметів, чи з якихось онлайн курсів, чи щось подібне. Також це може бути невеличкий open-source проект. Можна взяти кілька невеликих програм з метою їх подальшого об’єднання. Код має бути досить складним – тобто не рівня Hello world чи реалізації одного нескладного алгоритму (хоча це може бути кілька схожих чи якось пов’язаних алгоритмів, і на подальших кроках можна буде створити для них спільний програмний інтерфейс).
Реалізувати unit tests, шо описують функціональність обраної програми. (Якщо такі тести вже існують – їх можна доповнити, або залишити як є)
Побудувати UML діаграми, що описують обрану програму. Варто описати сценарії використання (Use Case), структуру коду (Class, Component, Object, Composite Structure, Deployment, Package, Profile), логіку та поведінку програми (Sequence, Communication, Timing, Activity, Interaction Overview, State). Для побудови деяких діаграм можна використати автоматичну генерацію діаграм з коду; але при цьому діаграми мають бути зрозумілими. Наприклад, взяти 100 класів і кинути їх усі на одну діаграму класів – мабуть, не найкращий варіант 
Запропонувати якісь зміни в структурі/інтерфейсі/реалізації програми. Це може бути кращий object-oriented design, кращий поділ на компоненти чи відокремлення різних аспектів (наприклад, логіки програми від графічного інтерфейсу), використання якихось патернів проектування, можливість вибору різних варіантів реалізації і т.д. Бажано використовувати побудовану модель програми для опису запропонованих змін. Запропоновані зміни треба узгодити з викладачем.
Реалізувати запропоновані зміни.
Перевірити, що нова версія програми не вносить зміни в логіку/алгоритми (якщо це не було заплановано). Використати для цього реалізовані раніше unit tests і аналогічні тести, які будуть реалізовані для нової версії.
Порівняти попередню та оновлену версії програми за часом виконання окремих алгоритмів/функцій, обсягом коду і т.д. Мета цієї частини – покращити структуру коду, зробити його більш гнучким та розширюваним. Як частину перетворень, можна реалізувати нову функціональність чи виправити недоліки в попередній – але це має бути додатково до покращень object-oriented design, а не замість нього.
Частина 3. Peer Review (Architecture/Design) В цій частині студенти переглядають моделі (зокрема, UML діаграми), що були реалізовані іншими студентами (в попередніх частинах 1 та 2), описують свої враження від них і пропонують покращення. Під час перегляду моделей варто відповісти на такі питання:

Наскільки моделі є зрозумілими, наскільки вони описують предметну область, структуру та поведінку відповідної системи?
Чи є якісь аспекти, які видаються важливими, але не відображені в моделі (на діаграмах)?
Чи є в моделі щось зайве, якісь аспекти описані занадто детально?
Наскільки доцільно використані різні типи діаграм?
Наскільки коректно використана нотація UML, різні елементи та конектори?
Наскільки вдалим є глосарій? Чи всі важливі поняття предметної області описано? Чи немає неоднозначностей?
Чи всі важливі сценарії використання описано в моделі? Наскільки зрозумілі різні сценарії, зв’язки між ними?
Наскільки доцільним є поділ системи на частини/компоненти/модулі/…?
Наскільки доцільними є зв’язки між компонентами/класами/об’єктами? Чи немає занадто тісно зв’язаних компонентів?
Наскільки object-oriented design відповідає загальним принципам? Студенти-автори моделей отримають доступ до коментарів студентів, які робили review, і матимуть змогу покращити моделі – чи пояснити, чому вони не погоджуються із знайденими недоліками/запропонованими покращеннями. Варто зазначити, що студентам-авторам моделей не будуть знижуватись бали за те, що інші студенти знайшли недоліки в їх моделях (за умови, що ці недоліки будуть виправлені). Тому не варто приховувати знайдені проблеми в моделях своїх колег – це не допоможе авторам моделей, а лише знизить бали, отримані за цю 3 частину студентами- reviewers. Для цієї частини дедлайни мають особливу структуру – на review виділяється певний час (орієнтовно 2 тижні?) після того, як автори моделей надали ці моделі для review. Проте варто розуміти, що якщо автори моделей затримуються з виконанням 1 та 2 частин лабораторної – то це створює незручності для інших студентів, які будуть робити review. Тому reviewers можуть заохочувати авторів відповідних моделей до більш швидкого завершення 1 та 2 частин. Бонусна частина. Враження від інструменту моделювання чи малювання діаграм Для отримання додаткових балів можна скласти короткий звіт-ретроспективу про використаний інструмент моделювання. Цей звіт аналогічний тому, який виконувався для лабораторної роботи № 3 минулого семестру. Звіт складається в довільній формі, бажано відповісти на наступні питання:
Чому було обрано саме цей інструмент, а не аналоги?
Наскільки просто та зрозуміло було отримати, встановити, налаштувати та почати використовувати цей інструмент?
Наскільки зрозумілою та корисною була документація інструмент?
Наскільки було зрозуміло, як саме використовувати інструмент, які функції/засоби/вікна/елементи керування використовувати для вирішення поставлених задач?
Чи всі 14 типів діаграм з UML 2.5 підтримує інструмент? Якщо ні – вкажіть, які саме не підтримуються
Чи всі можливості, доступні на кожному типі діаграм, підтримує інструмент? Якщо ні – вкажіть, що саме не підтримується, та для якого типу діаграм.
Чи використовували якісь додаткові можливості інструменту, наприклад генерацію коду з діаграм чи відновлення діаграм з коду? Наскільки гарно та правильно працюють ці можливості?
Наскільки зручно було використовувати інструмент, чи не треба було виконувати багато надлишкових дій?
Наскільки зрозумілою була поведінка інструменту в різних ситуаціях? Чи не виникали ситуації, коли незрозуміло, чому були виконані якісь дії чи як досягли певного стану?
Чи виникали якісь проблеми з використанням інструменту? Чи вдалось їх вирішити, як саме?
Що хорошого можна сказати про цей інструмент, які були позитивні аспекти використання інструменту?
Що поганого можна сказати про цей інструмент, які були негативні аспекти використання інструменту?
Якби довелось вирішувати аналогічну задачу, але вже враховуючи досвід використання в цій лабораторній роботі, що варто було б робити так само, а що змінити? Можливо, використати інший інструмент, чи використати інші можливості цього інструменту, чи інакше організувати процес розробки діаграм, чи ще щось?
#Task2

Розробити програму для демонстрації роботи певного класу алгоритмів (Варіант - алгоритми сортування). Програма має реалізовувати графічний інтерфейс користувача (наприклад, з використанням Qt або інших фреймворків), збереження даних (наприклад, в файли чи базу даних). Цю лабораторну роботу бажано виконувати в командах з 3-4 студентів (команди можуть бути такими ж, як для проектів, або відрізнятись.) Програма має бути спроектована таким чином, щоб був поділ на відносно незалежні компоненти, і можливість різним учасникам команди працювати над різними компонентами незалежно. В репозиторії має бути видно, ким був написаний кожен фрагмент коду (варіант «один з команди комітить за всіх» не приймається). Можливі ідеї для компонентів:

Власне реалізації алгоритмів, структур даних.
Механізм виміру продуктивності алгоритмів (час виконання, обсяг пам’яті)
Механізм оцінки теоретичної складності алгоритмів.
Механізм підбору параметрів алгоритмів з метою підвищення продуктивності.
Візуалізація поведінки алгоритмів
Візуалізація теоретичної та практичної продуктивності алгоритмів (таблиці, графіки, …)
Документація щодо алгоритмів
Інші можливі компоненти, які мають сенс для цієї задачі Можна розбити програму на дві частини: 1) бібліотеку з реалізацією алгоритмів чи структур даних та 2) застосунок з графічним інтерфейсом, який буде використовувати написану бібліотеку. Необхідно підготувати документацію реалізованої програми. Зокрема, треба описати заплановану архітектуру програми (використовуючи текстові описи та/або UML діаграми). Також має бути опис того, як використовувати можливості програми – як через графічний інтерфейс, так і з коду. Необхідно реалізувати юніт-тести для перевірки реалізованих алгоритмів. Зокрема, необхідно реалізувати перевірку того, що різні версії алгоритмів (тобто різні версії одного алгоритму) повертають однакові значення, якщо вони так мають працювати. Або перевірити властивості чи інваріанти структур даних чи алгоритмів (наприклад, що збалансоване дерево має приблизно однакову висоту у всіх гілках). Юніт-тести мають більш-менш покривати реалізовану функціональність алгоритмів. Робити тести для інтерфейсу користувача, збереження даних в БД і т.д. не обов’язково (хоча можна, для отримання додаткових балів)
Використання патернів проектування Мета цієї лабораторної роботи – навчитись реалізовувати і використовувати на практиці патерни проектування (design patterns). Тому бажано реалізувати хоча б основні і найбільш популярні патерни. Ідеї щодо використання патернів:

Патерн Strategy – варто використати для реалізації алгоритмів, з можливістю заміни реалізації без зміни клієнтського коду
Патерн Template Method – варто використати для реалізації варіантів алгоритмів, коли загальна структура лишається незмінною, але якісь аспекти реалізуються по-різному в підкласах
Патерн Composite – варто використати для реалізації складних алгоритмів, які містять під-алгоритми. Можна також використати для реалізації структур даних.
Патерн Decorator – варто використати для модифікацій алгоритмів, наприклад алгоритми з додатковою перевіркою правильності параметрів. Також варто використати для вимірів часу виконання. Можна використати і для інших модифікацій.
Патерн Iterator– варто використати для обходу структур даних.
Патерн Adapter– варто використати з метою використання бібліотечних реалізацій алгоритмів (зі стандартної бібліотеки або сторонніх бібліотек)
Патерн Abstract Factory / Factory Method– варто використати для побудови стандартних реалізацій певних алгоритмів (залежно від налаштувань)
Патерн Builder– варто використати для побудови складних алгоритмів, які складаються з багатьох частин
Патерн Singleton– варто використати для підтримки класів, які мають існувати в одному екземплярі і бути доступними іншим класам (наприклад, класи для побудови алгоритмів)
Патерн Visitor– варто використати для розрахунку певних властивостей складних алгоритмів/структур даних, наприклад теоретичної складності чи обсягу пам’яті
Патерн Bridge– варто використати для створення кількох версій інтерфейсу алгоритму чи структури даних, і незалежного розвитку їх реалізацій
Патерн Command– варто використати для реалізації інтерактивного режиму роботи з алгоритмами, зокрема можливість виконувати послідовність операцій, а також режим «машини часу» з можливістю повернути назад операції
Патерн Memento– варто використати для збереження та відновлення стану алгоритмів та структур даних (можливість завершити програму посередині інтерактивного режиму і потім відновитись з тої ж позиції)
Патерн Facade– варто використати для загального інтерфейсу компонентів та взаємодії компонентів між собою.
Інші патерни як з книги GoF, так і з інших джерел – варто використовувати там, де це доцільно. Зазвичай є рекомендація «не зловживати» використанням патернів, тобто не намагатись втиснути в одну програму усі патерни, які відомі розробнику. Для цієї лабораторної з демонстраційною метою можна послабити цю рекомендацію: тобто якщо в деякій ситуації можна реалізувати щось або з патернами, або без патернів – то варто про це написати в документації, і варто реалізувати варіант з патернами. (Можна також реалізувати обидва варіанти і додати механізм вибору між ними; за якісну реалізацію будуть виставлені додаткові бали) Можливі варіанти Варіанти цієї лабораторної будуються навколо певного класу близьких алгоритмів. Необхідно реалізувати різні алгоритми з обраного класу, починаючи від простих і до досить складних. Можливі ідеї варіантів
Списки і схожі структури
Дерева (в тому числі балансовані дерева пошуку)
Індексовані таблиці (реалізації на основі хеш-таблиць та дерев)
Сортування
Алгоритми на графах
Комбінаторні алгоритми (зокрема, з використанням динамічного програмування, backtracking, методу гілок і границь, …)
Алгоритми дискретної оптимізації (пошук максимуму/мінімуму)
Алгоритми теорії чисел
Алгоритми лінійної алгебри (вектори, матриці, лінійні рівняння, …)
Алгоритми математичного аналізу (похідні, інтеграли, як символьні, так і чисельні алгоритми)
Чисельні методи
Алгоритми математичної статистики В рамках однієї теми можна фокусуватись на різних аспектах алгоритмів. Можна також запропонувати свою тему, але треба погодити її з викладачем.
